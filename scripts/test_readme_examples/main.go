// Command test_readme_examples, when run at the /ably directory, generates
// a readme_examples_test.go file with the examples from README.md.
//
// Packages to import can be added at the top with comments like:
//
// 	<!-- GO IMPORT "path/to/import" -->
//
// Also, Go code that isn't part of the visible example but needs to be included
// in the resulting test can be added like:
//
// 	<!-- GO EXAMPLE
// 	... code goes here ...
// 	-->
//
// README code may use fmt.Println and fmt.Printf, which are mocked as no-ops
// in the actual test.
//
// The test runs against a sandbox app. When copying README code, this:
//
// 	ably.WithKey("xxx:xxx")
//
// is replaced with:
//
// 	ably.WithKey(app.Key()), ably.WithEnvironment(app.Environment), ably.WithUseBinaryProtocol(!ablytest.NoBinaryProtocol), ably.WithClientID("clientID")
//
// And this:
//
// 	ably.WithKey("invalid:key")
//
// does the same, except it doesn't replace "invalid:key" with app.Key().
//
// So that the REST and Realtime instances can run against the app, without
// polluting the README with test plumbing.
//
// The generated Go code includes references to the README.md line from which
// it's derived, for debugging.
package main

import (
	"bufio"
	"bytes"
	"errors"
	"fmt"
	"go/format"
	"io"
	"os"
	"strings"
)

func main() {
	src, err := os.Open("../README.md")
	try(err)
	defer src.Close()

	var out bytes.Buffer

	(&writer{}).write(&out, src)
	b, err := format.Source(out.Bytes())
	try(err)

	dst, err := os.Create("readme_examples_test.go")
	try(err)
	defer dst.Close()

	try(dst.Write(b))
}

type writer struct {
	out io.Writer
	in  *bufio.Reader

	lineNum     int
	pendingLine string
	eof         bool
}

type state func() state

func (w *writer) write(out io.Writer, src io.Reader) {
	w.out = out
	w.in = bufio.NewReader(src)

	var state state = w.writeHeader
	for state != nil {
		state = state()
	}
}

const (
	goImportPrefix = "<!-- GO IMPORT "
	goCommentBegin = "<!-- GO EXAMPLE"
	goBlockBegin   = "```go"
)

func (w *writer) writeHeader() state {
	w.writeln(`// Generated by test_readme_examples. DO NOT EDIT`)
	w.writeln(`package ably_test`)
	w.writeln(`import "testing"`)
	w.writeln(`import "github.com/ably/ably-go/ably"`)
	w.writeln(`import "github.com/ably/ably-go/ably/internal/ablytest"`)

loop:
	for {
		lineNum, l, ok := w.nextLine()
		if !ok {
			return nil
		}

		switch {
		case l == goCommentBegin:
			w.pendingLine = l
			break loop
		case l == goBlockBegin:
			w.pendingLine = l
			break loop
		case !strings.HasPrefix(l, goImportPrefix):
			continue
		}

		l = l[len(goImportPrefix):] // remove prefix
		l = l[:len(l)-len(" -->")]  // remove suffix
		w.writeln(`/*`, readmeRef(lineNum), `*/`, `import`, l)
	}

	w.writeln(`func TestReadmeExamples(t *testing.T) {`)
	w.writeln(`t.Parallel()`)

	// Fake fmt so that tests don't actually print things.
	w.writeln(`
		fmt := struct {
			Println func(a ...interface{}) (n int, err error)
			Printf func(s string, a ...interface{}) (n int, err error)
		}{
			Println: func(a ...interface{}) (n int, err error) { return 0, nil },
			Printf: func(s string, a ...interface{}) (n int, err error) { return 0, nil },
		}
	`)

	w.writeln(`app := ablytest.MustSandbox(nil)`)
	w.writeln(`defer safeclose(t, app)`)

	return w.writeMain
}

func (w *writer) writeMain() state {
	for {
		_, l, ok := w.nextLine()
		if !ok {
			w.writeln(`}`)
			return nil
		}

		switch l {
		case goCommentBegin:
			return w.writeGo(`-->`)
		case goBlockBegin:
			return w.writeGo("```")
		}
	}
}

func (w *writer) writeGo(endBlock string) state {
	for {
		lineNum, l, ok := w.nextLine()
		if !ok {
			break
		}

		if l == endBlock {
			break
		}

		sandboxOptions := `ably.WithEnvironment(app.Environment), ably.WithUseBinaryProtocol(!ablytest.NoBinaryProtocol), ably.WithClientID("clientID")`
		l = strings.ReplaceAll(l,
			`ably.WithKey("xxx:xxx")`,
			`ably.WithKey(app.Key()), `+sandboxOptions,
		)
		l = strings.ReplaceAll(l,
			`ably.WithKey("invalid:key")`,
			`ably.WithKey("invalid:key"), `+sandboxOptions,
		)

		w.writeln(`/*`, readmeRef(lineNum), `*/`, l)
	}

	return w.writeMain
}

func (w *writer) nextLine() (int, string, bool) {
	if l := w.pendingLine; l != "" {
		w.pendingLine = ""
		return w.lineNum, l, true
	}
	for {
		if w.eof {
			return 0, "", false
		}

		l, err := w.in.ReadString('\n')
		w.lineNum++
		if errors.Is(err, io.EOF) {
			w.eof = true
		} else {
			try(err)
			l = l[:len(l)-1] // remove '\n'
		}

		if l == "" { // ignore empty lines
			continue
		}

		return w.lineNum, l, true
	}
}

func (w *writer) writeln(args ...interface{}) {
	try(fmt.Fprintln(w.out, args...))
}

func try(args ...interface{}) {
	err := args[len(args)-1]
	if err != nil {
		panic(err)
	}
}

func readmeRef(lineNum int) string {
	return fmt.Sprintf("README.md:%d", lineNum)
}
